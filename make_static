#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""The perfect_control ROS node

This ROS node makes sure the configuration of the robot in the Gazebo simulator
always exactly represents the desired configuration published via ROS JointState
messages. It bypasses the usual control pipeline, which consists of feeding the
desired configuration to joint controllers and letting them control the physical
model of the robot in the simulator. 

The perfect_control node is particularly useful if you want to use Gazebo as a 
visualization tool, without relying on its physics engine.

In order to start the perfect_control node, you need to tell it which robot it 
shall control and where the desired configuration of the robot is published. 
This information is passed in the form of private ROS parameters. See the
following examples:

Examples: 
    # Control a robot named "R2D2" by listening to sensor_msgs/JointState 
    # messages on topic "/R2D2/joints".
    $ rosrun perfect_control perfect_control _robot:=R2D2 _topic:=/R2D2/joints

    # Control a robot named "baxter" by listening to topic "/joint_state".
    $ rosrun perfect_control perfect_control _robot:=baxter _topic:=/joint_state
"""


import argparse
import xml.etree.ElementTree
import os

def make_static(root):
    for child in root.getchildren():
        make_static(child)

    if root.tag == 'model':
        static = root.find('static')
        if static is None:
            root.insert(0, xml.etree.ElementTree.Element('static', text='true'))
        else:
            static.text = 'true'

        for joint in root.findall('joint'):
            root.remove(joint)


# Start the perfect_control ROS node.
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Remove joints')
    parser.add_argument('input_file')
    parser.add_argument('output_file', nargs='*')
    args = parser.parse_args()

    if args.output_file:
        ext = os.path.splitext(args.output_file[0])[1].lower()
        if ext not in ['.sdf', '.xml']:
            args.output_file[0] += '.sdf'

    sdf = xml.etree.ElementTree.parse(args.input_file)
    root = sdf.getroot()

    make_static(root)

    if args.output_file:
        sdf.write(args.output_file[0])
    else:
        xml.etree.ElementTree.dump(root)
